//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.18063
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
/// <summary>
/// 一条路线所包含的信息封装
/// </summary>
public class MissionRoadSample
{
	public int mapId = 0;//属地图编号

	public string road;//路径名字

	public string environment;//环境名字

	public int pointCount;//点位数量

	public string[] segmentTypes;//片段类型

	public bool segmentRandom;//片段类型是否是随机

	/// <summary>
	/// Initializes a new instance of the <see cref="MissionRoadSample"/> class.
	/// </summary>
	/// <param name="_mapId">属地图编号.</param>
	/// <param name="_road">3d场景的路径名</param>
	/// <param name="_environment">环境名</param>
	/// <param name="_pointCount">关卡所有点位总数量</param>
	/// <param name="_types">片段数据,null=随机生成片段</param>
	public  MissionRoadSample (int _mapId,string _road, string _environment,int _pointCount,string _types)
	{
		mapId=_mapId;
		road=_road;
		environment=_environment;
		pointCount=_pointCount;
		if(_types=="null")
		{
			segmentRandom=true;
			segmentTypes=null;
		}else
		{
			segmentRandom=false;
			segmentTypes=_types.Split(',');
		}
	}
	/// <summary>
	/// 更新路线的总的点位数量
	/// </summary>
	/// <param name="_pointCount">_point count.</param>
	public void M_updatePointCount(int _pointCount)
	{
		pointCount=_pointCount;
	}
	/// <summary>
	/// 根据一个路段模型 构建该路线的的：路径构建的顺序，
	/// </summary>
	/// <param name="_currentRoad">_current road.</param>
	public void M_creatRandom(MissionRoad _currentRoad)
	{
		segmentTypes=null;
		int tempTotalStep=0;
		List<string> tempTyps=new List<string>();
		EnumRoadSegment type;

		bool fristLineHasCreat=false;
		while(tempTotalStep<=pointCount)
		{
			if(tempTotalStep==0)
			{
				type=EnumRoadSegment.Start;
			}else if(pointCount-tempTotalStep<=_currentRoad.segments_end.totalSteps)
			{
				type=EnumRoadSegment.End;
			}else
			{
				if(!fristLineHasCreat)
				{
					type=EnumRoadSegment.Middle_Line;
					fristLineHasCreat=true;
				}else
				{
					type=EnumRoadSegmentKit.M_getRandomMiddleRandom();
				}
			}
			tempTotalStep+=_currentRoad.M_getSegmentStepCount(type);
			tempTyps.Add(Enum.GetName(typeof(EnumRoadSegment),type));
		}
		segmentTypes=tempTyps.ToArray();
		tempTyps.Clear();
		tempTyps=null;
	}
	/// <summary>
	/// 根据片段索引 返回该片段的旋转
	/// </summary>
	/// <returns>The segment rotation.</returns>
	/// <param name="_segmentIndex">_segment index.</param>
	public Vector3 M_getSegmentRotation(int _segmentIndex)
	{
		Vector3 initRoation=Vector3.zero;
		if(_segmentIndex>=segmentTypes.Length)
		{
			return initRoation;
		}
		EnumRoadSegment type;
		for(int i=0;i<=_segmentIndex;i++)
		{
			type=(EnumRoadSegment)Enum.Parse(typeof(EnumRoadSegment),segmentTypes[i]);
			switch(type)
			{
				case EnumRoadSegment.Start:					
				case EnumRoadSegment.End:					
				case EnumRoadSegment.Middle_Line:
				break;					
				case EnumRoadSegment.Middle_Left:
					initRoation+=new Vector3(0,-90,0);
				break;					
				case EnumRoadSegment.Middle_Right:
					initRoation+=new Vector3(0,90,0);
				break;
			}
		}
		return initRoation;
	}
	
} 

